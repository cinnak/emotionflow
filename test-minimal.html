<!DOCTYPE html>
<html>
<head>
  <title>Minimal Particle Test</title>
  <style>
    body { margin: 0; background: #0d1219; min-height: 100vh; overflow: hidden; }
    #particleCanvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 300; pointer-events: none; }
    #info { position: fixed; top: 20px; left: 20px; color: white; font-family: monospace; z-index: 400; background: rgba(0,0,0,0.5); padding: 20px; }
    button { padding: 10px 20px; font-size: 16px; cursor: pointer; background: #f0805a; color: white; border: none; border-radius: 4px; }
  </style>
</head>
<body>
  <div id="info">
    <h2>Minimal Particle System Test</h2>
    <button onclick="test1()">Test 1: Simple Circle</button>
    <button onclick="test2()">Test 2: Text Particles</button>
    <button onclick="test3()">Test 3: Holding Phase</button>
    <p id="status">Click a button to test</p>
  </div>
  <canvas id="particleCanvas"></canvas>

  <script>
    const canvas = document.getElementById('particleCanvas');
    const ctx = canvas.getContext('2d');

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      console.log('Canvas size:', canvas.width, 'x', canvas.height);
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    const PALETTE = {
      peak: '#f0805a',
      journey: ['#6c2a2a', '#a03030', '#c04040', '#f0805a', '#ffb080', '#ffdcc7']
    };

    // EXACT copy from app.js
    class Particle {
      constructor(x, y, emotion, palette) {
        this.x = x;
        this.y = y;
        this.originX = x;
        this.originY = y;
        this.emotion = emotion;
        this.palette = palette;

        this.vx = 0;
        this.vy = 0;
        this.gravity = 0.15;
        this.friction = 0.99;

        this.size = 4 + Math.random() * 3;
        this.baseSize = this.size;
        this.life = 1.0;
        this.decay = 0.003 + Math.random() * 0.003;
        this.color = palette.peak;
        this.colorIndex = 0;
        this.journey = palette.journey;

        this.phase = 'holding';
        this.delay = Math.random() * 500;
      }

      explode() {
        console.log('Particle exploding at', this.x, this.y);
        this.phase = 'exploding';
        const power = 12 + Math.random() * 20;
        const angle = Math.random() * Math.PI * 2;
        this.vx = Math.cos(angle) * power;
        this.vy = Math.sin(angle) * power - 3;
        this.decay = 0.012 + Math.random() * 0.008;
      }

      update() {
        if (this.phase === 'holding') {
          this.delay -= 16;
          if (this.delay <= 0) {
            this.explode();
          }
          return true;
        }

        if (this.phase === 'exploding') {
          this.vy += this.gravity;
          this.vx *= this.friction;
          this.x += this.vx;
          this.y += this.vy;
          this.life -= this.decay;
        }

        const progress = 1 - this.life;
        this.colorIndex = Math.floor(progress * (this.journey.length - 1));
        this.colorIndex = Math.min(this.colorIndex, this.journey.length - 1);

        return this.life > 0;
      }

      draw(ctx) {
        ctx.fillStyle = this.journey[this.colorIndex];
        ctx.globalAlpha = this.life;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Test 1: Simple explosion from center
    function test1() {
      console.log('=== Test 1: Simple Circle Explosion ===');
      document.getElementById('status').textContent = 'Test 1: Simple circle...';

      const particles = [];
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;

      for (let i = 0; i < 50; i++) {
        const angle = (i / 50) * Math.PI * 2;
        const p = new Particle(centerX, centerY, 'anger', PALETTE);
        p.phase = 'exploding'; // Skip holding phase
        p.vx = Math.cos(angle) * 10;
        p.vy = Math.sin(angle) * 10;
        p.size = 8;
        particles.push(p);
      }

      console.log('Created', particles.length, 'particles');

      function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        let alive = false;
        particles.forEach(p => {
          if (p.update()) {
            alive = true;
            p.draw(ctx);
          }
        });

        ctx.globalAlpha = 1;
        if (alive) {
          requestAnimationFrame(animate);
        } else {
          console.log('Test 1 complete');
          document.getElementById('status').textContent = 'Test 1 complete!';
        }
      }
      animate();
    }

    // Test 2: Text particles (like app.js)
    function test2() {
      console.log('=== Test 2: Text Particles ===');
      document.getElementById('status').textContent = 'Test 2: Text particles...';

      const text = 'TEST';
      const particles = [];

      const offCanvas = document.createElement('canvas');
      const offCtx = offCanvas.getContext('2d');
      offCanvas.width = canvas.width;
      offCanvas.height = canvas.height;

      const fontSize = 64;
      offCtx.font = '600 ' + fontSize + 'px "Inter", sans-serif';
      offCtx.fillStyle = '#ffffff';
      offCtx.textAlign = 'center';
      offCtx.textBaseline = 'middle';
      offCtx.fillText(text, canvas.width / 2, canvas.height / 2);

      const imageData = offCtx.getImageData(0, 0, canvas.width, canvas.height);
      const pixels = imageData.data;
      const gap = 5;

      for (let y = 0; y < canvas.height; y += gap) {
        for (let x = 0; x < canvas.width; x += gap) {
          const index = (y * canvas.width + x) * 4;
          if (pixels[index + 3] > 128) {
            const p = new Particle(x, y, 'anger', PALETTE);
            p.phase = 'exploding'; // Skip holding
            const angle = Math.random() * Math.PI * 2;
            const speed = 5 + Math.random() * 10;
            p.vx = Math.cos(angle) * speed;
            p.vy = Math.sin(angle) * speed;
            particles.push(p);
          }
        }
      }

      console.log('Created', particles.length, 'particles from text');

      function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        let alive = false;
        particles.forEach(p => {
          if (p.update()) {
            alive = true;
            p.draw(ctx);
          }
        });

        ctx.globalAlpha = 1;
        if (alive) {
          requestAnimationFrame(animate);
        } else {
          console.log('Test 2 complete');
          document.getElementById('status').textContent = 'Test 2 complete!';
        }
      }
      animate();
    }

    // Test 3: Holding phase (like the real app)
    function test3() {
      console.log('=== Test 3: Holding Phase Test ===');
      document.getElementById('status').textContent = 'Test 3: Holding phase...';

      const text = 'HOLD';
      const particles = [];

      const offCanvas = document.createElement('canvas');
      const offCtx = offCanvas.getContext('2d');
      offCanvas.width = canvas.width;
      offCanvas.height = canvas.height;

      const fontSize = 64;
      offCtx.font = '600 ' + fontSize + 'px "Inter", sans-serif';
      offCtx.fillStyle = '#ffffff';
      offCtx.textAlign = 'center';
      offCtx.textBaseline = 'middle';
      offCtx.fillText(text, canvas.width / 2, canvas.height / 2);

      const imageData = offCtx.getImageData(0, 0, canvas.width, canvas.height);
      const pixels = imageData.data;
      const gap = 5;

      for (let y = 0; y < canvas.height; y += gap) {
        for (let x = 0; x < canvas.width; x += gap) {
          const index = (y * canvas.width + x) * 4;
          if (pixels[index + 3] > 128) {
            const p = new Particle(x, y, 'anger', PALETTE);
            // Keep in holding phase
            particles.push(p);
          }
        }
      }

      console.log('Created', particles.length, 'particles in holding phase');

      let frameCount = 0;
      function animate() {
        frameCount++;
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Explode after 1 second
        if (frameCount === 60) {
          console.log('Triggering explosion for all particles');
          particles.forEach(p => {
            p.delay = 0;
          });
        }

        let alive = 0;
        particles.forEach(p => {
          if (p.update()) {
            alive++;
            p.draw(ctx);
          }
        });

        ctx.globalAlpha = 1;

        if (frameCount % 30 === 0) {
          console.log('Frame', frameCount + ', Alive:', alive);
        }

        if (alive > 0) {
          requestAnimationFrame(animate);
        } else {
          console.log('Test 3 complete');
          document.getElementById('status').textContent = 'Test 3 complete!';
        }
      }
      animate();
    }

    console.log('Minimal particle test loaded. Canvas ready.');
  </script>
</body>
</html>
